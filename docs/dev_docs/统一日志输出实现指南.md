# 统一日志输出实现指南

## 概述
本文档详细记录了如何在Spring Boot项目中实现统一的日志输出系统，包括标准化日志格式、分环境配置、日志分类存储、接口访问日志和业务日志记录。

## 项目结构
```
src/main/java/com/yourpackage/
├── util/
│   └── LogUtil.java            # 统一日志工具类
├── interceptor/
│   └── LogInterceptor.java     # 请求日志拦截器
├── aspect/
│   └── LogAspect.java          # 日志切面
├── config/
│   └── LogConfig.java          # 日志配置
├── annotation/
│   └── LogBusiness.java        # 业务日志注解
└── controller/
    └── LogDemoController.java  # 使用示例

src/main/resources/
├── logback-spring.xml          # 日志配置文件
└── application.yml             # 环境配置
```

## 实现步骤

### 1. 添加依赖
在 `pom.xml` 中添加必要依赖：
```xml
<!-- AOP依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>

<!-- JSON处理 -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
</dependency>
```

### 2. 创建日志配置文件
**文件路径**: `src/main/resources/logback-spring.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration scan="true" scanPeriod="60 seconds" debug="false">
    <!-- 定义日志文件的存储地址 -->
    <property name="LOG_HOME" value="logs"/>
    <property name="APP_NAME" value="YourAppName"/>
    
    <!-- 控制台输出 -->
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%logger{50}] - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!-- 主日志文件 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_HOME}/${APP_NAME}.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <FileNamePattern>${LOG_HOME}/${APP_NAME}.%d{yyyy-MM-dd}.%i.log</FileNamePattern>
            <MaxHistory>30</MaxHistory>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%logger{50}] - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!-- 错误日志文件 -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_HOME}/${APP_NAME}_error.log</file>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <FileNamePattern>${LOG_HOME}/${APP_NAME}_error.%d{yyyy-MM-dd}.%i.log</FileNamePattern>
            <MaxHistory>30</MaxHistory>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%logger{50}] - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!-- 业务日志文件 -->
    <appender name="BUSINESS_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_HOME}/${APP_NAME}_business.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <FileNamePattern>${LOG_HOME}/${APP_NAME}_business.%d{yyyy-MM-dd}.%i.log</FileNamePattern>
            <MaxHistory>30</MaxHistory>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%logger{50}] - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!-- SQL日志文件 -->
    <appender name="SQL_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_HOME}/${APP_NAME}_sql.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <FileNamePattern>${LOG_HOME}/${APP_NAME}_sql.%d{yyyy-MM-dd}.%i.log</FileNamePattern>
            <MaxHistory>30</MaxHistory>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%logger{50}] - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!-- 开发环境 -->
    <springProfile name="dev">
        <root level="DEBUG">
            <appender-ref ref="STDOUT"/>
            <appender-ref ref="FILE"/>
            <appender-ref ref="ERROR_FILE"/>
        </root>
        
        <logger name="org.mybatis" level="DEBUG" additivity="false">
            <appender-ref ref="SQL_FILE"/>
            <appender-ref ref="STDOUT"/>
        </logger>
        
        <logger name="java.sql" level="DEBUG" additivity="false">
            <appender-ref ref="SQL_FILE"/>
            <appender-ref ref="STDOUT"/>
        </logger>
        
        <logger name="com.yourpackage" level="DEBUG" additivity="false">
            <appender-ref ref="BUSINESS_FILE"/>
            <appender-ref ref="STDOUT"/>
        </logger>
    </springProfile>

    <!-- 测试环境 -->
    <springProfile name="test">
        <root level="INFO">
            <appender-ref ref="FILE"/>
            <appender-ref ref="ERROR_FILE"/>
        </root>
        
        <logger name="com.yourpackage" level="INFO" additivity="false">
            <appender-ref ref="BUSINESS_FILE"/>
        </logger>
    </springProfile>

    <!-- 生产环境 -->
    <springProfile name="prod">
        <root level="INFO">
            <appender-ref ref="FILE"/>
            <appender-ref ref="ERROR_FILE"/>
        </root>
        
        <logger name="com.yourpackage" level="INFO" additivity="false">
            <appender-ref ref="BUSINESS_FILE"/>
        </logger>
    </springProfile>
</configuration>
```

### 3. 创建统一日志工具类（优化版）
**文件路径**: `src/main/java/com/yourpackage/util/LogUtil.java`

```java
package com.yourpackage.util;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * 统一日志工具类（优化版）
 * 优化内容：
 * 1. 安全序列化，避免复杂对象序列化错误
 * 2. 优化错误日志记录
 * 3. 避免记录404等正常错误
 */
public class LogUtil {

    private static final ObjectMapper objectMapper = new ObjectMapper();
    
    /**
     * 获取Logger实例
     */
    public static Logger getLogger(Class<?> clazz) {
        return LoggerFactory.getLogger(clazz);
    }

    /**
     * 设置请求追踪ID
     */
    public static void setTraceId() {
        String traceId = UUID.randomUUID().toString().replace("-", "");
        MDC.put("traceId", traceId);
    }

    /**
     * 获取请求追踪ID
     */
    public static String getTraceId() {
        return MDC.get("traceId");
    }

    /**
     * 清除请求追踪ID
     */
    public static void clearTraceId() {
        MDC.clear();
    }

    /**
     * 记录业务日志
     */
    public static void logBusiness(Logger logger, String operation, Object request, Object response) {
        try {
            String requestStr = serializeSafely(request);
            String responseStr = serializeSafely(response);
            
            String logMessage = String.format(
                "[业务日志] 操作: %s, 请求: %s, 响应: %s",
                operation, requestStr, responseStr
            );
            logger.info(logMessage);
        } catch (Exception e) {
            logger.error("[业务日志] 操作: {} - 记录日志失败: {}", operation, e.getMessage());
        }
    }

    /**
     * 记录接口访问日志
     */
    public static void logAccess(Logger logger, String method, String uri, String ip, 
                               Object params, Object result, long duration) {
        try {
            String paramsStr = serializeSafely(params);
            String resultStr = serializeSafely(result);
            
            String logMessage = String.format(
                "[接口访问] %s %s, IP: %s, 参数: %s, 耗时: %dms, 结果: %s",
                method, uri, ip, paramsStr, duration, resultStr
            );
            logger.info(logMessage);
        } catch (Exception e) {
            logger.error("[接口访问] {} {}, IP: {}, 耗时: {}ms - 记录日志失败: {}", 
                       method, uri, ip, duration, e.getMessage());
        }
    }

    /**
     * 记录异常日志
     */
    public static void logException(Logger logger, String operation, Throwable throwable, Object... params) {
        try {
            String paramsStr = serializeSafely(params.length > 0 ? params : "无");
            String logMessage = String.format(
                "[异常日志] 操作: %s, 参数: %s, 异常: %s",
                operation, paramsStr, throwable.getMessage()
            );
            logger.error(logMessage, throwable);
        } catch (Exception e) {
            logger.error("[异常日志] 操作: {} - 记录日志失败: {}", operation, e.getMessage());
        }
    }

    /**
     * 记录性能日志
     */
    public static void logPerformance(Logger logger, String operation, long duration, Object... params) {
        try {
            String paramsStr = serializeSafely(params.length > 0 ? params : "无");
            String logMessage = String.format(
                "[性能日志] 操作: %s, 耗时: %dms, 参数: %s",
                operation, duration, paramsStr
            );
            logger.info(logMessage);
        } catch (Exception e) {
            logger.error("[性能日志] 操作: {} - 记录日志失败: {}", operation, e.getMessage());
        }
    }

    /**
     * 记录调试日志
     */
    public static void logDebug(Logger logger, String operation, Object... params) {
        if (logger.isDebugEnabled()) {
            try {
                String paramsStr = serializeSafely(params.length > 0 ? params : "无");
                String logMessage = String.format(
                    "[调试日志] 操作: %s, 参数: %s",
                    operation, paramsStr
                );
                logger.debug(logMessage);
            } catch (Exception e) {
                logger.error("[调试日志] 操作: {} - 记录日志失败: {}", operation, e.getMessage());
            }
        }
    }

    /**
     * 记录SQL日志
     */
    public static void logSql(Logger logger, String sql, Object... params) {
        try {
            String paramsStr = serializeSafely(params.length > 0 ? params : "无");
            String logMessage = String.format(
                "[SQL日志] SQL: %s, 参数: %s",
                sql, paramsStr
            );
            logger.debug(logMessage);
        } catch (Exception e) {
            logger.error("[SQL日志] SQL记录失败: {}", e.getMessage());
        }
    }

    /**
     * 记录用户操作日志
     */
    public static void logUserAction(Logger logger, String userId, String action, Object details) {
        try {
            String detailsStr = serializeSafely(details);
            String logMessage = String.format(
                "[用户操作] 用户ID: %s, 操作: %s, 详情: %s",
                userId, action, detailsStr
            );
            logger.info(logMessage);
        } catch (Exception e) {
            logger.error("[用户操作] 记录日志失败: {}", e.getMessage());
        }
    }

    /**
     * 记录安全日志
     */
    public static void logSecurity(Logger logger, String userId, String action, String ip, Object details) {
        try {
            String detailsStr = serializeSafely(details);
            String logMessage = String.format(
                "[安全日志] 用户ID: %s, 操作: %s, IP: %s, 详情: %s",
                userId, action, ip, detailsStr
            );
            logger.warn(logMessage);
        } catch (Exception e) {
            logger.error("[安全日志] 记录日志失败: {}", e.getMessage());
        }
    }

    /**
     * 安全序列化对象
     */
    private static String serializeSafely(Object obj) {
        if (obj == null) {
            return "null";
        }
        
        try {
            // 避免序列化复杂对象
            if (isComplexObject(obj)) {
                return String.valueOf(obj);
            }
            
            return objectMapper.writeValueAsString(obj);
        } catch (Exception e) {
            return "[无法序列化: " + obj.getClass().getSimpleName() + "]";
        }
    }
    
    /**
     * 判断是否为复杂对象（避免序列化）
     */
    private static boolean isComplexObject(Object obj) {
        if (obj == null) return false;
        
        String className = obj.getClass().getName();
        return className.contains("HttpServletRequest") ||
               className.contains("HttpServletResponse") ||
               className.contains("HttpSession") ||
               className.contains("ServletContext") ||
               className.contains("Principal") ||
               className.contains("Session") ||
               className.contains("Request") ||
               className.contains("Response");
    }

    /**
     * 构建日志上下文
     */
    public static Map<String, Object> buildContext(String key, Object value) {
        Map<String, Object> context = new HashMap<>();
        context.put(key, value);
        return context;
    }
}
```

## 优化改进总结

### 1. 序列化安全优化
为避免序列化复杂对象（如HttpServletRequest、Session等）导致的错误，添加了安全序列化方法：

- **问题**: Jackson无法序列化HttpServletRequest、Session等复杂对象
- **解决方案**: 添加`serializeSafely`方法，智能识别复杂对象并使用`toString()`代替序列化

### 2. 404错误优化
为避免记录大量404错误日志，在日志拦截器和切面中添加了过滤逻辑：

- **问题**: 大量404错误日志干扰正常日志分析
- **解决方案**: 在拦截器和切面中添加过滤逻辑，忽略404等正常错误

### 3. 静态资源过滤
在日志配置中排除了静态资源路径：

- **问题**: 静态资源访问产生大量无效日志
- **解决方案**: 排除静态资源路径，如`/css/**`、`/js/**`、`/images/**`等

### 4. 错误日志优化
改进了错误日志的记录方式：

- **问题**: 日志记录失败时产生二次错误
- **解决方案**: 简化错误日志格式，避免循环错误

## 使用示例

```java
@RestController
@RequestMapping("/log-demo")
public class LogDemoController {

    private static final Logger logger = LogUtil.getLogger(LogDemoController.class);

    @GetMapping("/test")
    public Map<String, Object> testLog(@RequestParam(defaultValue = "test") String name) {
        Map<String, Object> params = new HashMap<>();
        params.put("name", name);
        LogUtil.logDebug(logger, "测试日志记录", params);
        
        Map<String, Object> result = new HashMap<>();
        result.put("message", "Hello " + name);
        result.put("timestamp", System.currentTimeMillis());
        
        LogUtil.logBusiness(logger, "测试业务操作", params, result);
        return result;
    }
}
```

## 测试验证

启动项目后，可以通过以下接口测试：
- `GET /log-demo/test?name=test` - 测试基础日志
- `GET /log-demo/business?userId=123` - 测试业务日志注解
- `GET /log-demo/user-action?userId=123&action=login` - 测试用户操作日志

## 注意事项

1. **日志文件大小**: 单个日志文件最大100MB，保留30天
2. **敏感信息**: 避免在日志中记录密码、token等敏感信息
3. **性能影响**: 生产环境避免记录过多DEBUG日志
4. **JSON序列化**: 复杂对象使用安全序列化，避免错误
5. **追踪ID**: 所有日志自动包含追踪ID，便于链路追踪
6. **404优化**: 自动过滤404等正常错误，减少干扰日志