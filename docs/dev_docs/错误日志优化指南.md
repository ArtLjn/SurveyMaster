# 错误日志优化指南

## 概述

本指南记录了如何优化Spring Boot项目中的错误日志输出，减少不必要的堆栈跟踪信息，提升日志的可读性和系统性能。

## 问题描述

在业务异常（如BusinessException）抛出时，控制台输出过多的错误信息，包括完整的堆栈跟踪，影响日志的可读性和系统性能。

## 优化方案

### 1. 修改LogUtil异常日志方法

在<mcfile name="LogUtil.java" path="/Users/ljn/Documents/demo/SurveyMaster/src/main/java/org/practice/surveymaster/util/LogUtil.java"></mcfile>中，优化异常日志记录方式：

#### 优化前的问题
```java
public static void logException(Logger logger, String operation, Throwable throwable, Object... params) {
    // 问题：这里传入了throwable，会导致输出完整堆栈
    logger.error(logMessage, throwable);
}
```

#### 优化后的方案
```java
/**
 * 记录异常日志（不包含堆栈信息）
 */
public static void logException(Logger logger, String operation, Throwable throwable, Object... params) {
    try {
        String paramsStr = serializeSafely(params.length > 0 ? params : "无");
        String logMessage = String.format(
            "[异常日志] 操作: %s, 参数: %s, 异常类型: %s, 异常消息: %s",
            operation, paramsStr, throwable.getClass().getSimpleName(), throwable.getMessage()
        );
        // 优化：不再传入throwable参数，避免输出堆栈
        logger.error(logMessage);
    } catch (Exception e) {
        logger.error("[异常日志] 操作: {} - 记录日志失败: {}", operation, e.getMessage());
    }
}

/**
 * 记录异常日志（包含堆栈信息）- 需要时使用
 */
public static void logExceptionWithStackTrace(Logger logger, String operation, Throwable throwable, Object... params) {
    try {
        String paramsStr = serializeSafely(params.length > 0 ? params : "无");
        String logMessage = String.format(
            "[异常日志] 操作: %s, 参数: %s, 异常类型: %s, 异常消息: %s",
            operation, paramsStr, throwable.getClass().getSimpleName(), throwable.getMessage()
        );
        // 只在需要时输出堆栈
        logger.error(logMessage, throwable);
    } catch (Exception e) {
        logger.error("[异常日志] 操作: {} - 记录日志失败: {}", operation, e.getMessage());
    }
}
```

### 2. 修改全局异常处理器

在<mcfile name="GlobalExceptionHandler.java" path="/Users/ljn/Documents/demo/SurveyMaster/src/main/java/org/practice/surveymaster/exception/GlobalExceptionHandler.java"></mcfile>中，优化日志记录方式：

#### 业务异常处理优化
```java
@ExceptionHandler(BusinessException.class)
public ResponseEntity<ApiResponse<Object>> handleBusinessException(BusinessException e, HttpServletRequest request) {
    // 优化前：输出完整堆栈
    // log.warn("业务异常: {}", e.getMessage(), e);
    
    // 优化后：只输出关键信息
    log.warn("业务异常 - 错误码: {}, 消息: {}, 路径: {}", 
            e.getErrorCode().getCode(), e.getMessage(), request.getRequestURI());
    
    // ... 其他逻辑
}
```

#### 系统异常处理优化
```java
@ExceptionHandler(Exception.class)
public ResponseEntity<ApiResponse<Void>> handleException(Exception e, HttpServletRequest request) {
    // 优化前：输出完整堆栈
    // log.error("系统异常: {}", e.getMessage(), e);
    
    // 优化后：只输出关键信息
    log.error("系统异常 - 类型: {}, 消息: {}, 路径: {}", 
            e.getClass().getSimpleName(), e.getMessage(), request.getRequestURI());
    
    // ... 其他逻辑
}
```

### 3. 统一日志格式

所有异常处理方法都采用统一的日志格式：
- 警告级别（warn）：业务异常、参数验证异常
- 错误级别（error）：系统异常、运行时异常
- 格式：`异常类型 - 关键信息: {}, 路径: {}`

### 4. 保留关键信息

虽然减少了堆栈信息，但仍保留了以下关键信息：
- 错误码（业务异常）
- 异常消息
- 请求路径
- 异常类型（系统异常）
- 参数名（参数异常）

## 优化效果

### 优化前日志输出（LogUtil.logException）
```
[异常日志] 操作: 用户登录, 参数: ["admin","123456"], 异常: 用户不存在
org.practice.surveymaster.exception.BusinessException: 用户不存在
    at org.practice.surveymaster.service.impl.UserServiceImpl.login(UserServiceImpl.java:50)
    at org.practice.surveymaster.service.impl.UserServiceImpl$$FastClassBySpringCGLIB$$5206581e.invoke(<generated>)
    at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)
    at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:783)
    ... (几十行堆栈信息)
```

### 优化后日志输出
```
[异常日志] 操作: 用户登录, 参数: ["admin","123456"], 异常类型: BusinessException, 异常消息: 用户不存在
```

### 全局异常处理器优化效果
**优化前：**
```
org.practice.surveymaster.exception.BusinessException: 用户不存在
    at org.practice.surveymaster.service.impl.UserServiceImpl.login(UserServiceImpl.java:50)
    at org.practice.surveymaster.service.impl.UserServiceImpl$$FastClassBySpringCGLIB$$5206581e.invoke(<generated>)
    at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)
    ... (几十行堆栈信息)
```

**优化后：**
```
业务异常 - 错误码: USER_NOT_FOUND, 消息: 用户不存在, 路径: /api/user/login
```

## 使用建议

### 1. 选择合适的日志方法

- **普通业务异常**：使用`logException()`方法，不输出堆栈
- **重要系统异常**：使用`logExceptionWithStackTrace()`方法，输出堆栈用于调试

```java
// 普通业务异常，不输出堆栈
LogUtil.logException(logger, "用户登录", new BusinessException("用户不存在"), username);

// 重要系统异常，输出堆栈
LogUtil.logExceptionWithStackTrace(logger, "数据库连接", new SQLException("连接超时"), dbConfig);
```

### 2. 环境配置

**开发环境**：可以开启详细日志
```yaml
logging:
  level:
    org.practice.surveymaster: DEBUG
```

**生产环境**：建议使用优化后的配置
```yaml
logging:
  level:
    org.practice.surveymaster: INFO
```

### 3. 日志监控

配合日志监控系统，及时发现异常模式：
- 统计异常类型频率
- 监控业务异常趋势
- 设置告警阈值

## 相关配置

### 日志级别配置（application.yml）
```yaml
logging:
  level:
    org.practice.surveymaster: INFO
    org.springframework.web: WARN
```

### 开发环境详细日志
```yaml
# application-dev.yml
logging:
  level:
    org.practice.surveymaster: DEBUG
    org.springframework.web: DEBUG
```

## 总结

通过优化LogUtil和全局异常处理器中的日志记录方式，可以：

### 主要改进
- **LogUtil.logException()**：不再输出堆栈信息，只记录关键异常信息
- **LogUtil.logExceptionWithStackTrace()**：新增方法，在需要时输出完整堆栈
- **全局异常处理器**：统一格式，减少冗余信息

### 核心收益
- **减少日志量**：避免控制台被堆栈信息淹没
- **提升可读性**：关键信息一目了然
- **降低系统开销**：减少I/O操作和日志存储
- **保持调试能力**：重要异常仍可输出堆栈

### 最佳实践
1. **业务异常**：使用`logException()`，不输出堆栈
2. **系统异常**：根据重要性选择是否输出堆栈
3. **生产环境**：保持简洁日志配置
4. **开发环境**：可开启详细日志便于调试

这种分层优化方式特别适合企业级应用，在保持错误追踪能力的同时，显著提升系统性能和日志质量。